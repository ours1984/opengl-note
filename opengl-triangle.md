---
title: '从零开始画三角形'
date: '2021/7/25 22:46:25'
tags: [CG,OpenGL]
abbrlink: opengl-triangle
gitrep: opengl-note
---
当你画出三角形,你已经知道如下知识:OpenGL api,OpenGL缓冲区,glsl shader语言,渲染循环,以及窗口事件

[Blog Links: https://blog.ours1984.top/posts/opengl-triangle](https://blog.ours1984.top/posts/opengl-triangle)

本文手把手带领大家搭建OpenGL环境,建立工程,画出一个三角形.
<!--more-->

## 现代OpenGL

早期的OpenGL也就是OpenGL1.5以前使用立即渲染模式（Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便,只需要cpu端渲染指令发送给gpu即可。OpenGL的大多数功能都被库隐藏起来，开发者很少有控制OpenGL如何进行计算的自由。而开发者迫切希望能有更多的灵活性。随着时间推移，规范越来越灵活，开发者对绘图细节有了更多的掌控。立即渲染模式确实容易使用和理解，但是效率太低。OpenGL2.0出现了核心模式,并且从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。

当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。现代函数的优势是更高的灵活性和效率，然而也更难于学习。立即渲染模式从OpenGL实际运作中抽象掉了很多细节，因此它在易于学习的同时，也很难让人去把握OpenGL具体是如何运作的。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。

核心模式需要使用者编写gpu端运行的shader代码,入门门槛相对于兼容模式,提高了很多.本文只讲核心模式

{% note warning %}
当使用新版本的OpenGL特性时，只有新一代的显卡能够支持你的应用程序。这也是为什么大多数开发者基于较低版本的OpenGL编写程序，并只提供选项启用新版本的特性
{% endnot %}

核心模式涉及到下图这么多概念

![20220525153527](https://pic.ours1984.top/img/20220525153527.png!shuiyin)

总结起来三个方面

- OpenGL对象: 渲染的数据来源,需要在cpu里构造好,并传送到gpu,包括缓冲对象/纹理对象/帧缓冲对象
- 渲染管线: gpu渲染的流程,理解了这个流程,我们才能知道怎么去组织数据,怎么去串联显示
- GLSL: 也就是传说中的shader编写了.有了数据和算法,你需要通过glsl语法写出来,并交给gpu编译出可运行的代码

## 渲染管线

![20220525154106](https://pic.ours1984.top/img/20220525154106.png!shuiyin)

图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。

显卡有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)

为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)

OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。

## shader

![20220525154230](https://pic.ours1984.top/img/20220525154230.png!shuiyin)

在现代OpenGL中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。出于这个原因，刚开始学习现代OpenGL的时候可能会非常困难，因为在你能够渲染自己的第一个三角形之前已经需要了解一大堆知识了。在本节结束你最终渲染出你的三角形的时候，你也会了解到非常多的图形编程知识。

一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)

顶点着色器：输入 顶点属性                       输出  自定义，一般需要设置gl_posision
几何着色器：输入 图元所有顶点输出                输出  新生成图元，可以处理法向，可丢弃图元
片段着色器：输入 自定义                         输出  片段颜色，可设置片段深度，可丢弃片段

## 基础缓冲对象

### vertex buffer object

顶点数据：由顶点属性组成，每个属性由用户自定义。至少定义这些属性：顶点3D坐标
我们需要发送顶点数据到GPU显存
我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个显存。

配置OpenGL如何解释显存，并且指定其如何发送给显卡

顶点着色器接着会处理我们在内存中指定数量的顶点

![20220525154457](https://pic.ours1984.top/img/20220525154457.png!shuiyin)

### index buffer object

和顶点缓冲对象一样，IBO也是一个缓冲，它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点。所谓的索引绘制(Indexed Drawing)正是我们问题的解决方案。

### vertex array object

这不是一个缓冲对象,它仅仅记录了一些列绑定操作

![20220525154812](https://pic.ours1984.top/img/20220525154812.png!shuiyin)

## 编译着色器

1.创建着色器  2.编译着色器 3.创建program 4.链接着色器  5.删除着色器

## 加入窗口渲染循环


